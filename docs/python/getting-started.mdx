---
title: Getting started
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Connect is a slim library for building HTTP APIs consumable anywhere, including browsers.
You define your service with a Protocol Buffer schema, and Connect generates type-safe server
and client code. Fill in your server's business logic and you're done â€” no hand-written
marshaling, routing, or client code required!

This fifteen-minute walkthrough helps you create a small Connect service in Python.
It demonstrates what you'll be writing by hand, what Connect generates for you,
and how to call your new API.

## Prerequisites

- [uv](https://docs.astral.sh/uv/#installation) installed. Any package manager including pip can also be used.
- [The Buf CLI](https://buf.build/docs/installation) installed, and include it in the `$PATH`.
- We'll also use [cURL](https://curl.se/). It's available from Homebrew and most Linux package managers.

## Set up Python environment

First, we'll setup the Python environment and dependencies.

<Tabs groupId="python-type">
  <TabItem value="async" label="ASGI">

      ```bash
      uv init
      uv add connect-python uvicorn
      ```

  </TabItem>
  <TabItem value="sync" label="WSGI">

    ```bash
    uv init
    uv add connect-python gunicorn
    ```

  </TabItem>
</Tabs>

## Define a service

Now we're ready to write the Protocol Buffer schema that defines our service. In your shell,

```bash
mkdir -p proto/greet/v1
touch proto/greet/v1/greet.proto
```

Open `proto/greet/v1/greet.proto` in your editor and add:

```protobuf
syntax = "proto3";

package greet.v1;

message GreetRequest {
  string name = 1;
}

message GreetResponse {
  string greeting = 1;
}

service GreetService {
  rpc Greet(GreetRequest) returns (GreetResponse) {}
}
```

This file declares the `greet.v1` Protobuf package, a service called `GreetService`, and a single method
called `Greet` with its request and response structures. These package, service, and method names will
reappear soon in our HTTP API's URLs.

## Generate code

We're going to generate our code using [Buf](https://buf.build/), a modern replacement for Google's protobuf compiler.

First, scaffold a basic [buf.yaml](https://buf.build/docs/configuration/v2/buf-yaml) by running `buf config init`.
Then, edit `buf.yaml` to use our `proto` directory:

```yaml hl_lines="2 3"
version: v2
modules:
  - path: proto
lint:
  use:
    - DEFAULT
breaking:
  use:
    - FILE
```

We will use [remote plugins](https://buf.build/docs/bsr/remote-plugins/usage), a feature of the
[Buf Schema Registry](https://buf.build/docs/tutorials/getting-started-with-bsr) for generating code. Tell buf how to
generate code by creating a buf.gen.yaml:

```bash
touch buf.gen.yaml
```

```yaml
version: v2
plugins:
  - remote: buf.build/protocolbuffers/python
    out: .
  - remote: buf.build/protocolbuffers/pyi
    out: .
  - remote: buf.build/connectrpc/python
    out: .
```

With those configuration files in place, you can lint your schema and generate code:

```bash
buf lint
buf generate
```

In the `greet` package, you should now see some generated Python:

```
greet
  â””â”€â”€ v1
      â”œâ”€â”€ greet_connect.py
      â””â”€â”€ greet_pb2.py
      â””â”€â”€ greet_pb2.pyi
```

The package `greet/v1` contains `greet_pb2.py` and `greet_pb2.pyi` which were generated by
the [protocolbuffers/python](https://buf.build/protocolbuffers/python) and
[protocolbuffers/pyi](https://buf.build/protocolbuffers/pyi) and contain `GreetRequest`
and `GreetResponse` structs and the associated marshaling code. `greet_connect.py` was
generated by [connectrpc/python](https://buf.build/connectrpc/python) and contains the
WSGI and ASGI service interfaces and client code to access a Connect server. Feel free to
poke around if you're interested - `greet_connect.py` is standard Python code.

## Implement service

The code we've generated takes care of the boring boilerplate, but we still need to implement our greeting logic.
In the generated code, this is represented as the `greet_connect.GreetService` and `greet_connect.GreetServiceSync`
interfaces for async ASGI and sync WSGI servers respectively. Since the interface is so small, we can do everything
in one Python file. `touch server.py` and add:

<Tabs groupId="python-type">
  <TabItem value="async" label="ASGI">

    ```python
    from greet.v1.greet_connect import GreetService, GreetServiceASGIApplication
    from greet.v1.greet_pb2 import GreetResponse

    class Greeter(GreetService):
        async def greet(self, request, ctx):
            print("Request headers: ", ctx.request_headers())
            response = GreetResponse(greeting=f"Hello, {request.name}!")
            ctx.response_headers()["greet-version"] = "v1"
            return response

    app = GreetServiceASGIApplication(Greeter())
    ```

  </TabItem>
  <TabItem value="sync" label="WSGI">

    ```python
    from greet.v1.greet_connect import GreetServiceSync, GreetServiceWSGIApplication
    from greet.v1.greet_pb2 import GreetResponse

    class Greeter(GreetServiceSync):
        def greet(self, request, ctx):
            print("Request headers: ", ctx.request_headers())
            response = GreetResponse(greeting=f"Hello, {request.name}!")
            ctx.response_headers()["greet-version"] = "v1"
            return response

    app = GreetServiceWSGIApplication(Greeter())
    ```

  </TabItem>
</Tabs>

In a separate terminal window, you can now start your server:

<Tabs groupId="python-type">
  <TabItem value="async" label="ASGI">

    ```bash
    uv run uvicorn server:app
    ```

  </TabItem>
  <TabItem value="sync" label="WSGI">

    ```bash
    uv run gunicorn server:app
    ```

  </TabItem>
</Tabs>

## Make requests

The simplest way to consume your new API is an HTTP/1.1 POST with a JSON payload. If you have a recent version of
cURL installed, it's a one-liner:

```bash
curl \
  --header "Content-Type: application/json" \
  --data '{"name": "Jane"}' \
  http://localhost:8000/greet.v1.GreetService/Greet
```

This responds:

```json
{
  "greeting": "Hello, Jane!"
}
```

We can also make requests using Connect's generated client. `touch client.py` and add:

<Tabs groupId="python-type">
  <TabItem value="async" label="Async">

    ```python
    import asyncio

    from greet.v1.greet_connect import GreetServiceClient
    from greet.v1.greet_pb2 import GreetRequest

    async def main():
        client = GreetServiceClient("http://localhost:8000")
        res = await client.greet(GreetRequest(name="Jane"))
        print(res.greeting)

    if __name__ == "__main__":
        asyncio.run(main())
    ```

  </TabItem>
  <TabItem value="sync" label="Sync">

    ```python
    from greet.v1.greet_connect import GreetServiceClientSync
    from greet.v1.greet_pb2 import GreetRequest

    def main():
        client = GreetServiceClientSync("http://localhost:8000")
        res = client.greet(GreetRequest(name="Jane"))
        print(res.greeting)

    if __name__ == "__main__":
        main()
    ```

  </TabItem>
</Tabs>

With your server still running in a separate terminal window, you can now run your client:

```bash
uv run python client.py
```

Congratulations â€” you've built your first Connect service! ðŸŽ‰

## So what?

With just a few lines of hand-written code, you've built a real API server that supports both the and Connect protocol.
Unlike a hand-written REST service, you didn't need to design a URL hierarchy, hand-write request and response structs,
manage your own marshaling, or parse typed values out of query parameters. More importantly, your users got an idiomatic,
type-safe client without any extra work on your part.
