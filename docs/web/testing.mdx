---
title: Testing
sidebar_position: 20
---

Testing a client application can be a crucial part of ensuring its functionality
and performance. When it comes to web applications, spinning up a full server
to test against may not always be the best option. In the following sections, we
will go through a couple of alternatives.

## Component Testing

Component testing is one strategy for verifying the behavior of an application. It allows you to test smaller
pieces in isolation, enabling you to focus on behavior in a more constrained context. Frameworks each have their own
concept of a 'component' so running these in unit tests varies depending on your use case. Luckily, there are utilities
such as the popular [`@testing-library`](https://testing-library.com/docs/), which is family of packages that provides
APIs for various frameworks such as React, Vue, and Svelte. These packages assist you with rendering
your component, querying for elements, and verifying their behavior.

For components that interface with Connect, it will generally be desirable to mock your RPCs since you don't
want unit tests issuing actual network calls to endpoints, potentially mutating data on the server. To facilitate this,
it is recommended to structure your Connect components so that the `Transport` interface is passed to your component
rather than created within it.

Once this setup is in place, you can then being to mock a transport in your unit tests and
pass this mock to your components. The easiest way to do this is via Connect's `createRouterTransport` function.

### Mocking Transports

The function `createRouterTransport` from `@connectrpc/connect` creates an in-memory
server with your own RPC implementations. To illustrate, let's setup a very
simple ELIZA service:

```ts
import { ElizaService } from "@buf/connectrpc_eliza.connectrpc_es/connectrpc/eliza/v1/eliza_connect";
import { SayResponse } from "@buf/connectrpc_eliza.connectrpc_es/connectrpc/eliza/v1/eliza_pb";
import { createRouterTransport } from "@connectrpc/connect";

const mockTransport = createRouterTransport(({ service }) => {
  service(ElizaService, {
    say: () => new SayResponse({ sentence: "I feel happy." }),
  });
});
```

Under the hood, this mock transport runs nearly the same code that a server running on
Node.js would run. This means that all features from [implementing real services](../node/implementing-services.md)
are available: You can access request headers, raise errors with details, and also
mock streaming responses. Here is an example that raises an error on the fourth
request:

```ts
const mockTransport = createRouterTransport(({ service }) => {
  const sentences: string[] = [];
  service(ElizaService, {
    say(request: SayRequest) {
      sentences.push(request.sentence);
      // highlight-next-line
      if (sentences.length > 3) {
      // highlight-next-line
        throw new ConnectError(
      // highlight-next-line
          "I have no words anymore.",
      // highlight-next-line
          Code.ResourceExhausted,
      // highlight-next-line
        );
      // highlight-next-line
      }
      return new SayResponse({
        sentence: `You said ${sentences.length} sentences.`,
      });
    },
  });
});
```

You can also use expectations to assert that your client sends requests as expected:

```ts
const mockTransport = createRouterTransport(({ service }) => {
  service(ElizaService, {
    say(request) {
      // highlight-next-line
      expect(request.sentence).toBe("how do you feel?");
      return new SayResponse({ sentence: "I feel happy." });
    },
  });
});
```

The `createRouterTransport` function also accepts an optional second argument, allowing you
to pass options like [interceptors](./interceptors.mdx).

```ts
const mockTransport = createRouterTransport(
  ({ service }) => {
    service(ElizaService, {
      say(request) {
        return new SayResponse({ sentence: "I feel happy." });
      },
    });
  },
  {
    transport: {
      interceptors: [
        (next) => async (req) => {
          console.log(`sending message to ${req.url}`);
          return await next(req);
        },
      ],
    },
  },
);
```

As mentioned above, a recommended way to structure components that need to issue Connect calls is to pass a
`Transport` object to the component. This adds flexibility to components for unit testing, but will vary
depending on the framework being used.  Below are some examples.

### React

The recommended approach for providing a transport to components in React is through the use of
[React Context](https://react.dev/learn/passing-data-deeply-with-context). For example, you can create a custom
hook which reads the transport from `Context` and then your component can use this hook to create a Connect client.
Then, in your unit test, you can simply mock the transport value in `Context`.

For a working example of the above with Create React App, see the
[Create React App project](https://github.com/connectrpc/examples-es/tree/main/react/cra) in the
[examples-es](https://github.com/connectrpc/examples-es) repo.

### Svelte

The suggested method for providing transports to Svelte components is similar in that it makes use of Svelte's
[Context API](https://learn.svelte.dev/tutorial/context-api). The one gotcha to be aware of is that `setContext` and
`getContext` can only be called from within a component lifecycle, so utilizing this approach is a bit more complex.

To view a working example of mocking transports in Svelte components, check out the
[Svelte project](https://github.com/connectrpc/examples-es/tree/main/svelte) in the
[examples-es](https://github.com/connectrpc/examples-es) repo.

### Vue

Structuring a Vue application to allow for easy component testing involves Vue's [Provide/Inject API](https://vuejs.org/guide/components/provide-inject.html).
Using this approach, you can provide the transport to your app and then you can inject it in the `setup` of your
component and create a Connect client when your component is mounted.

For a working example of mocking transports in Vue components, see the
[Vue project](https://github.com/connectrpc/examples-es/tree/main/vue) in the
[examples-es](https://github.com/connectrpc/examples-es) repo.

### What about mocking `fetch` itself?

Mocking `fetch` itself is a common approach to testing network requests, but it has some drawbacks. Instead, using a schema-based serialization chain with an in-memory transport can be a better approach. Here are some reasons why:

- With schema-based serialization, the request goes through the same process as it would in your actual code, allowing you to test the full flow of your application.
- You can create stateful mocks with an in-memory transport, which can test more complex workflows and scenarios.
- An in-memory transport is fast, so you can quickly set up your tests without worrying about resetting mocks.
- With an in-memory transport, you can eliminate the need for [spy functions](https://jestjs.io/docs/jest-object#jestspyonobject-methodname) because you can implement any checks directly in your server implementation. This can simplify your testing code and make it easier to understand.
- You can leverage `expect` directly within the code of your mock implementation to verify particular scenarios pertaining to the requests or responses.


## End-to-end testing

[Playwright](https://playwright.dev/) is a powerful tool for testing complex web
applications. It can intercept requests and return mocked responses to the web
application under test. If you want to use Playwright with a Connect client, consider using
[@connectrpc/connect-playwright](https://www.npmjs.com/package/@connectrpc/connect-playwright)
to bring the type-safety of your schema to Playwright's [API Mocks](https://playwright.dev/docs/mock).

A basic example:

```ts
test.describe("mocking Eliza", () => {
  let mock: MockRouter;
  test.beforeEach(({ context }) => {
    mock = createMockRouter(context, {
      baseUrl: "https://demo.connectrpc.com",
    });
  });
  test("mock RPCs at service level", async ({ page }) => {
    await mock.service(ElizaService, {
      say: () => new SayResponse({ sentence: "I feel happy." }),
    });
    // Any calls to Eliza.Say in test code below will be intercepted and invoke
    // the implementation above.
  });
});
```

To get started, take a look at the [connect-playwright repository](https://github.com/connectrpc/connect-playwright-es),
and the [example project](https://github.com/connectrpc/connect-playwright-es/tree/main/packages/connect-playwright-example).

## Troubleshooting

### Jest and the jsdom environment

If you are using [jest-environment-jsdom](https://www.npmjs.com/package/jest-environment-jsdom),
you will very likely see an error when you run tests with the router transport,
the protobuf binary format, or any other code relying on the otherwise widely
available [encoding API](https://developer.mozilla.org/en-US/docs/Web/API/Encoding_API):

```
ReferenceError: TextEncoder is not defined
```

If you see this error, consider to use [@bufbuild/jest-environment-jsdom](https://www.npmjs.com/package/@bufbuild/jest-environment-jsdom)
instead.
