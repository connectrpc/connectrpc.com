---
title: Server-Side Rendering (SSR)
sidebar_position: 22
---

Many frameworks offer server-side rendering (SSR) support. For example, Vue, Svelte, and Next.js all provide the ability
to generate HTML on the server and send it to the client. This offers many benefits such as:

* The ability to incrementally render data without forcing the user to wait for the entire page to load.
* Resilience in the face of issues such as network connectivity, ad blockers, and obstacles to loading JavaScript.
* Better Search Engine Optimization (SEO) support.

SSR is not without its drawbacks, though. For example, it works great for generating
HTML, but gets complicated when you have complex data fetching needs. In addition, the
ecosystem supporting it is still in its infancy and each framework offers wildly different
approaches to implementing it.

That being said, it is possible to utilize Connect-ES as part of your SSR strategy for fetching data. Before doing so,
there are two main concepts to be aware of.

## Serialization Boundary

Any data generated on the server-side and returned to the client must be serializable to JSON. This is because the
data is crossing a serialization boundary when being transmitted from the server to the client. So, any data fetched
with Connect-ES must be made serializable when returning it from your SSR functions. Since the objects returned from a
Connect-ES RPC are generated by Protobuf-ES, they can easily be made SSR-compatible via one of two functions provided
by the Protobuf-ES runtime:

### `toPlainMessage`

The `toPlainMessage` function will convert a Protobuf-ES object into its [`PlainMessage`](https://github.com/bufbuild/protobuf-es/blob/main/docs/runtime_api.md#plainmessage)
equivalent, which is an object containing just the fields of a message and none of the message's methods. This allows
the message to be serialized to JSON and can then easily be returned from your server-side rendering functionality to
the client.

### `toJson` and `fromJson`

In addition to `toPlainMessage`, you can also convert your message to JSON explicitly using
[`toJson`](https://github.com/bufbuild/protobuf-es/blob/main/docs/runtime_api.md#json). The downside to this approach
is that you lose all type information when converted to JSON, but you can get it back in your client by simply
converting back into a message using `fromJson`.

## Absolute URLs

The second item to be aware of is that when creating Connect transports in SSR functions, you will need to specify an
absolute URL for the API your transport will be interacting with.

### Examples

A framework-agnostic example incorporating the above details:


```ts
import { toPlainMessage } from "@bufbuild/protobuf";
import { createPromiseClient } from "@connectrpc/connect";
import { createConnectTransport } from "@connectrpc/connect-web";
import { ElizaService } from "./gen/connectrpc/eliza/v1/eliza_connect";

export const serverSideFunction = async () => {
    const transport = createConnectTransport({
        // Using a relative path here like '/api' will not work.
        baseUrl: "https://demo.connectrpc.com",
    });
    const client = createPromiseClient(ElizaService, transport);
    const request = { sentence: "Hello from the server" };
    const response = await client.say(request);

    return {
        // Use toPlainMessage to make the response serializable
        response: toPlainMessage(response),
        // Or use toJson to convert it to JSON explicitly
        // Just remember to convert it back using fromJson if you want your original message types
        responseAsJson: response.toJson(),
    };
};
```

For full working examples using various frameworks, check out the [Svelte](https://github.com/connectrpc/examples-es/tree/main/svelte)
project and the [Next.js](https://github.com/connectrpc/examples-es/tree/main/nextjs) project in our
[examples-es](https://github.com/connectrpc/examples-es) repo.
