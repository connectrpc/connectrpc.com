---
title: Server-Side Rendering (SSR)
sidebar_position: 22
---

Many frameworks offer server-side rendering (SSR) support, which is the ability to render a page on the server-side and
then send this information to the client as HTML. SSR provides many benefits such as:

* Better Search Engine Optimization (SEO) support.
* Resilience in the face of issues such as network connectivity, ad blockers, and obstacles to loading JavaScript.
* The ability to incrementally render data without forcing the user to wait for the entire page to load.

The last point is where Connect-ES comes in. Consider a scenario where your application needs to make many API requests
for data that rarely changes. Using Connect-ES with SSR allows you to perform these fetches on the server, significantly
reducing the time to First Contentful Paint, which is a metric that measures the time from when the page starts loading
to when any part of the page's content is rendered on the screen

Connect-ES works with SSR out-of-the-box. Before doing so, there are two main concepts to be aware of.

## Serialization Boundary

Any data generated on the server-side and returned to the client must be serializable to JSON. Since the objects
returned from a Connect-ES RPC invocation are generated by Protobuf-ES, they can easily be made SSR-compatible via one
of two functions provided by the Protobuf-ES runtime:

### `toPlainMessage`

The `toPlainMessage` function will convert a Protobuf-ES object into its [`PlainMessage`](https://github.com/bufbuild/protobuf-es/blob/main/docs/runtime_api.md#plainmessage)
equivalent, which is an object containing just the fields of a message and none of the message's methods.

### `toJson` and `fromJson`

In addition to `toPlainMessage`, you can also convert your message to JSON explicitly using
[`toJson`](https://github.com/bufbuild/protobuf-es/blob/main/docs/runtime_api.md#json). The downside to this approach
is that you lose all type information when converted to JSON, but you can get it back in your client by simply
converting into the original message type using `fromJson`.

## Absolute URLs

The second item to be aware of is that when creating Connect transports in SSR functions, you will need to specify an
absolute URL for the API your transport will be interacting with.

### Examples

A framework-agnostic example incorporating the above details:


```ts
import { toPlainMessage } from "@bufbuild/protobuf";
import { createPromiseClient } from "@connectrpc/connect";
import { createConnectTransport } from "@connectrpc/connect-web";
import { ElizaService } from "./gen/connectrpc/eliza/v1/eliza_connect";

export const serverSideFunction = async () => {
    const transport = createConnectTransport({
        // Using a relative path here like '/api' will not work.
        baseUrl: "https://demo.connectrpc.com",
    });
    const client = createPromiseClient(ElizaService, transport);
    const request = { sentence: "Hello from the server" };
    const response = await client.say(request);

    return {
        // Use toPlainMessage to make the response serializable
        response: toPlainMessage(response),
        // Or use toJson to convert it to JSON explicitly
        // Just remember to convert it back using fromJson if you want your original message types
        responseAsJson: response.toJson(),
    };
};
```

For full working examples using various frameworks, check out the [Svelte](https://github.com/connectrpc/examples-es/tree/main/svelte)
project and the [Next.js](https://github.com/connectrpc/examples-es/tree/main/nextjs) project in our
[examples-es](https://github.com/connectrpc/examples-es) repo.
