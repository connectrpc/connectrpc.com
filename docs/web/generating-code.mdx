---
title: Generating code
sidebar_position: 3
---

We mentioned earlier that the ELIZA service defines a Protocol Buffer schema.
So what _is_ that schema? It is really just a simple file that describes the
service, its methods, and their argument and return types:

```protobuf
syntax = "proto3";

service ElizaService {
  rpc Say(SayRequest) returns (SayResponse) {}
}

message SayRequest {
  string sentence = 1;
}

message SayResponse {
  string sentence = 1;
}
```

You can see the full version including comments and some additional RPCs
[on the Buf Schema Registry](https://buf.build/connectrpc/eliza/file/main:connectrpc/eliza/v1/eliza.proto) (BSR).
The `rpc` keyword stands for Remote Procedure Call — a method you can invoke
remotely. The schema is the contract between server and client, and it
precisely defines how data is exchanged down to the very details of
serialization.

The schema comes to life by generating code. For the server, an interface
is generated, and the developer can focus on filling the methods with business
logic. For the client, there really isn't anything to do — the developer can
just call the client methods, rely on the generated types for compile-time
type-safety and serialization, and focus on the application logic.


## Remote packages

In the tutorial, we have been using [remote packages](https://buf.build/docs/bsr/remote-packages/npm) with an `npm install`
command. When the package was requested on the BSR NPM registry, it ran
the schema through a code generator, and served the generated files as a
package with all required dependencies.

If you want to use a Connect or gRPC service whose schema is published on the
BSR, you can simply use `npm` to install the package, and hit the service with
a Connect client.

See our [documentation on remote packages](https://buf.build/docs/bsr/remote-packages/overview)
for details.

## Local generation

We're going to generate our code using [Buf](https://buf.build/product/cli/),
a modern replacement for Google's protobuf compiler, and two compiler
plugins:

- `protoc-gen-connect-es` — generates services from your Protocol Buffer schema
- `protoc-gen-es` — generates base types, like request and response messages

The code we will generate has three runtime dependencies:

- **@bufbuild/connect** — provides clients, interceptors, errors, and other primitives for Connect
- **@bufbuild/connect-web** — provides the Connect and gRPC-web protocols for web browsers
- **@bufbuild/protobuf** — provides serialization and more for the base types

First, let's install `buf`, the plugins and runtime dependencies:

```bash
$ npm install --save-dev @bufbuild/buf @bufbuild/protoc-gen-connect-es @bufbuild/protoc-gen-es
$ npm install @bufbuild/connect @bufbuild/connect-web @bufbuild/protobuf
```

Next, tell Buf to use the two plugins with a new configuration file:

```yaml title="buf.gen.yaml"
# buf.gen.yaml defines a local generation template.
# For details, see https://buf.build/docs/configuration/v1/buf-gen-yaml
version: v1
plugins:
  - plugin: es
    out: gen
    # With target=ts, we generate TypeScript files.
    # Use target=js+dts to generate JavaScript and TypeScript declaration files
    # like remote generation does.
    opt: target=ts
  - plugin: connect-es
    out: gen
    # With target=ts, we generate TypeScript files.
    opt: target=ts
```

If desired, you can also skip local plugin installation and use [remote plugins](https://buf.build/docs/bsr/remote-plugins/overview).
See the [connect-es example](https://buf.build/docs/bsr/remote-plugins/usage#connect-web)
for a buf.gen.yaml which uses remote plugins.

Finally, tell Buf to generate code for the ELIZA schema:

```bash
$ npx buf generate buf.build/bufbuild/eliza
```

If you prefer, you can use `protoc` instead of Buf — the plugins behave like
any other plugin.

### Output

Let's take a peek at what was generated. There are two new files:

- `gen/connectrpc/eliza/v1/eliza_connect.ts`
- `gen/connectrpc/eliza/v1/eliza_pb.ts`

The first file was generated by `protoc-gen-connect-es` and contains the
service:

```ts
import { SayRequest, SayResponse } from "./eliza_pb.js";
import { MethodKind } from "@bufbuild/protobuf";

export const ElizaService = {
  typeName: "connectrpc.eliza.v1.ElizaService",
  methods: {
    say: {
      name: "Say",
      I: SayRequest,
      O: SayResponse,
      kind: MethodKind.Unary,
    },
  }
} as const;
```
The full file includes comments and additional RPCs, but the `const`
above really is all Connect needs to provide [clients](/docs/web/using-clients).

The second file was generated by `protoc-gen-es`, and contains the request and
response classes. You can see them being imported for the service definition.
To learn more about `protoc-gen-es`, head over to the documentation for the
[Protobuf-ES project](https://github.com/bufbuild/protobuf-es/blob/main/docs/generated_code.md).


### Using the local files

To use the locally generated files in the tutorial, update the import path:

```diff
- import { ElizaService } from "@buf/bufbuild_eliza.bufbuild_connect-es/connectrpc/eliza/v1/eliza_connect";
+ import { ElizaService } from "../gen/connectrpc/eliza/v1/eliza_connect";
```
